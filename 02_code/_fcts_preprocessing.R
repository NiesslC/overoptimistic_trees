

preprocess_apply_firstdaycorrect_fct = function(data, target_name, correction_factors){
  # We have to operate on contact level so get the corresponding names according to the considered target 
  if(target_name == "costpd"){
    target_name_contactlevel = "cost"
  } else if(target_name == "costpd_exclsys"){
    target_name_contactlevel = "cost_exclsys"
  } else if(target_name == "minutespd"){
    target_name_contactlevel = "minutes"
  } 
  
  # Add correction factors to data and recalculate target variable 
  data = full_join(data, correction_factors, by = c("setting", "team_id"))
  data = data %>%
    group_by(companion_id) %>% 
    mutate("{target_name_contactlevel}" := case_when(
      grp == 0 & date == min(date) ~ .data[[target_name_contactlevel]] * correction_factor_mean,
      !(grp == 0 & date == min(date)) ~ .data[[target_name_contactlevel]])) %>%
    group_by(companion_id, grp) %>% 
    mutate("{target_name}" := sum(.data[[target_name_contactlevel]])/phase_days) %>%
    ungroup() %>%
    select(-correction_factor_mean)
  
  return(data)
}

# fct should not be used on whole data set
preprocess_get_firstdaycorrect_fct = function(data, target_name){

  # We have to operate on contact level so get the corresponding names according to the considered target 
  if(target_name == "costpd"){
    target_name_contactlevel = "cost"
  } else if(target_name == "costpd_exclsys"){
    target_name_contactlevel = "cost_exclsys"
  } else if(target_name == "minutespd"){
    target_name_contactlevel = "minutes"
  } 
  
  # Get information whether a phase is the first one in the episode (only first days of each phase)
  data_firstday = data  %>%
    group_by(companion_id, grp, setting, team_id) %>% 
    filter(date == min(date)) %>% # only use first day
    summarise(target_daylevel = sum(.data[[target_name_contactlevel]])) %>% 
    ungroup() %>% 
    mutate(firstphase = ifelse(grp == 0, "first_phase_yes", "first_phase_no"))
  
  # (Make sure that there is only one value per phase = data_firstday is on phase level)
  stopifnot(all(data_firstday %>% group_by(companion_id, grp) %>% count() %>% .$n == 1))
  
  # Calculate correction factors
  data_firstday = data_firstday %>%
    group_by(setting, team_id, firstphase) %>%
    summarise(mean_target_daylevel = mean(target_daylevel)) %>% 
    ungroup()
  data_firstday_mean = data_firstday %>% spread(firstphase, mean_target_daylevel)
  data_firstday_mean = data_firstday_mean %>% mutate(correction_factor_mean = ifelse(first_phase_no/first_phase_yes < 1,
                                                                                     first_phase_no/first_phase_yes,1)) %>%
    select(-first_phase_yes, -first_phase_no)
  
  correction_factors = data_firstday_mean
  return(correction_factors)
}


preprocess_rmoutliers_fct = function(data, data_calc, targetname, option){
  if(option == "A"){
    # Option A ---- 
    # 100th percentile (do not remove outliers)
    percentile = 1.00
  } else if(option == "B"){
    # Option B ---- 
    # 99th percentile (do not remove outliers)
    percentile = 0.99
  } else if(option == "C"){
    # Option C ---- 
    # 95th percentile (do not remove outliers)
    percentile = 0.95
  } else if(option == "D"){
    # Option D ---- 
    # 90th percentile (do not remove outliers)
    percentile = 0.90
  }
  
  outlier_threshold = unname(unlist(data_calc %>% 
                                      ungroup() %>% 
                                      summarise(perc = quantile(.data[[target_name]], percentile))))
  data = data %>% filter(!!as.name(target_name) <= outlier_threshold)
  return(data)
}



preprocess_target_fct = function(data, option){ 
  
  if(option == "A"){
    # Option A ---- 
    # Use "cost_total" as target variable (remove "cost_total_exclsys" and "minutes_total" )
    data = data %>% select(-cost_total_exclsys,-minutes_total)
    target_name = "cost_total"
  } else if(option == "B"){
    # Option B ---- 
    # Use "cost_total_exclsys" as target variable (remove "cost_total" and "minutes_total" )
    data = data %>% select(-cost_total,-minutes_total)
    target_name = "cost_total_exclsys"
  } else if(option == "C"){
    # Option C ---- 
    # Use "minutes_total" as target variable (remove "cost_total" and "cost_total_exclsys" )
    data = data %>% select(-cost_total,-cost_total_exclsys)
    target_name = "minutes_total"
  }
  
  return(list("data" = data, "target_name" = target_name))
}


preprocess_feature_age_fct = function(data, option){ 
  if(option == "A"){
    # Option A ---- 
    # Leave age as continuous variable
    data = data
  } else if(option == "B"){
    # Option B ---- 
    # Categorize age (= factor variable, but not ordered factor!)
    data = data %>% 
      mutate(age =  cut(age, breaks = c(26,seq(50,90,10),102), include.lowest = TRUE ))
    stopifnot(sum(is.na(data$age))==0) # make sure that no NAs were generated by transformation
  }
  return(data)
  }


preprocess_feature_akps_fct = function(data, option){
  if(option == "A"){
    # Option A ---- 
    # Only collapse the AKPS categories 70,80,90, leave remaining categories as they are
    data = data %>% 
      mutate(akps = case_when(
        akps %in% c("70", "80", "90") ~ "70_80_90",
        .default = akps)) %>% 
      mutate(akps = factor(akps, ordered = TRUE))
  } else if(option == "B"){
    # Option B ---- 
    # Only collapse several AKPS categories (note: values 0 and 100 do not exist in the data)
    data = data %>% 
      mutate(akps = case_when(
        akps %in% c("10", "20") ~  "10_20",
        akps %in% c("30", "40", "50") ~  "30_40_50",
        akps %in% c("60", "70", "80", "90") ~ "60_70_80_90",
        .default = akps)) %>% 
      mutate(akps = factor(akps, ordered = TRUE))
  }
  return(data)
}


preprocess_feature_ipos_fct = function(data, option){
  if(option == "A"){
    # Option A ----
    # IPOS score defined as sum of all 17 IPOS variables with range [0,68]
    # (for each variable, 0 = least extreme value, 4 = most extreme value)
    # Handling of "cannot assess": "cannot assess" is set to NA which is equal to setting
    # these values to the least extreme value
    data = data %>%   
      mutate(across(starts_with("ipos"), ~ na_if(., "cannot assess"))) %>%
      mutate(across(starts_with("ipos"), ~ fct_drop(., only = c("cannot assess")))) %>%
      mutate(across(starts_with("ipos"), ~ as.integer(.)-1)) %>% 
      mutate(ipos_score = rowSums(across(starts_with("ipos")), na.rm =TRUE)) %>% 
      select(-setdiff(starts_with("ipos"), contains("ipos_score"))) # remove unused ipos vars
    feature_names = "ipos_score"
  } else if(option == "B"){
    # Option B ----
    # IPOS score similar to option A except that two separate scores are created, one for the 10
    # physical IPOS variables (range=[0,40]) and one for the remaining 7 non-physical IPOS 
    # variables (range=[0,28])
    # Handling of "cannot assess": "cannot assess" is set to NA which is equal to setting
    # these values to the least extreme value
    data = data %>% 
      mutate(across(starts_with("ipos"), ~ na_if(., "cannot assess"))) %>%
      mutate(across(starts_with("ipos"),~  fct_drop(., only = c("cannot assess")))) %>%
      mutate(across(starts_with("ipos"), ~ as.integer(.)-1)) %>% 
      mutate(ipos_score_phys = rowSums(across(c("ipos_pain",
                                                "ipos_shortness_breath","ipos_weakness","ipos_nausea","ipos_vomiting",
                                                "ipos_poor_appetite","ipos_constipation","ipos_sore_dry_mouth",
                                                "ipos_drowsiness", "ipos_poor_mobility")), na.rm =TRUE)) %>% 
      mutate(ipos_score_nonphys = rowSums(across(c("ipos_patient_anxiety","ipos_family_anxiety",
                                                   "ipos_depression","ipos_peace",
                                                   "ipos_sharing_feelings","ipos_information",
                                                   "ipos_practical_matters")), na.rm =TRUE)) %>% 
      select(-setdiff(starts_with("ipos"), contains("ipos_score"))) # remove unused ipos vars
    feature_names = c("ipos_score_phys", "ipos_score_nonphys")
  } else if(option == "C"){
    # Option C ----
    # IPOS score counting how many IPOS variables take the most extreme or second most extreme 
    # value, range = [0,17]
    # Handling of "cannot assess": By only accounting for the two most extreme values, 
    # "cannot assess" values are implicitly assumed to be at most equal to the third most extreme value
    data=data %>% mutate(across(starts_with("ipos"), 
                                ~ . %in% tail(levels(.)[!grepl("cannot assess",levels(.))], n=2))) %>%
      mutate(ipos_score_extreme = rowSums(across(starts_with("ipos")))) %>% 
      select(-setdiff(starts_with("ipos"), contains("ipos_score_extreme"))) # remove unused ipos vars
    
    feature_names = "ipos_score_extreme"
    
  } else if(option == "D"){
    # Option D ----
    # IPOS score similar to option C except that ipos_pain and ipos_shortness_breath are not 
    # included in the score but considered individually as ordinal variables.
    # Handling of "cannot assess": By only accounting for the two most extreme values, 
    # "cannot assess" values are implicitly assumed to be at most equal to the third most extreme value;
    # for ipos_pain and ipos_shortness_breath "cannot assess" is set to "not at all"
    data=data %>% mutate(across(setdiff(starts_with("ipos"), ends_with(c('pain','shortness_breath'))), 
                                ~ . %in% tail(levels(.)[!grepl("cannot assess",levels(.))], n=2))) %>%
      mutate(ipos_score_extreme_exclpb = rowSums(across(setdiff(starts_with("ipos"), ends_with(c('pain','shortness_breath')))))) %>% 
      mutate(across(c("ipos_pain", "ipos_shortness_breath"), ~ na_if(., "cannot assess"))) %>%
      mutate(across(c("ipos_pain", "ipos_shortness_breath"), ~  fct_drop(., only = c("cannot assess")))) %>%
      mutate(across(c("ipos_pain", "ipos_shortness_breath"), ~ replace_na(.,"not at all"))) %>%
      mutate(across(c("ipos_pain","ipos_shortness_breath"), ~ factor(., ordered = TRUE))) %>%
      select(-setdiff(starts_with("ipos"), ends_with(c("ipos_score_extreme_exclpb","ipos_pain","ipos_shortness_breath")))) # remove unused ipos vars
    
    feature_names = c("ipos_score_extreme_exclpb","ipos_pain","ipos_shortness_breath")
  } else if(option == "E"){
    
    # Option E ----
    # IPOS variables considered separately as ordinal variables, excluding some variables that 
    # likely do not have an effect on resources on their own 
    # Handling of "cannot assess": "cannot assess" is set to the corresponding least extreme value
    data = data %>% select(-ipos_sore_dry_mouth) %>%
      mutate(across(starts_with("ipos"), ~ na_if(., "cannot assess"))) %>%
      mutate(across(starts_with("ipos"), ~ fct_drop(., only = c("cannot assess")))) %>%
      mutate(across(starts_with("ipos"), ~ replace_na(.,levels(.)[1]))) %>%
      mutate(across(starts_with("ipos"), ~ factor(., ordered = TRUE)))
    ## Note: In case only the three most extreme values should be differentiated, use sth like below 
    # mutate(across(starts_with("ipos"), ~na_if(., "cannot assess"))) %>%
    # (fct_drop makes sure that only cannot assess is removed and not other unused factor levels to keep original scale)
    # mutate(across(starts_with("ipos"),~ fct_drop(., only = c("cannot assess")))) %>%
    # mutate(across(starts_with("ipos"), ~as.integer(.))) %>%
    # mutate(across(starts_with("ipos"), ~ -1*(. -(1+max(., na.rm =TRUE))))) %>%
    # mutate(across(starts_with("ipos"), ~ case_when(
    #   . == 1 ~ "overwhelmingly",
    #   . == 2 ~ "severely",
    #   . == 3 ~ "moderately",
    #   . %in% c(4,5) |is.na(.)~ "slightlyorless" )))%>%
    #   mutate(across(starts_with("ipos"),  ~ factor(., levels = c("slightlyorless","moderately","severely","overwhelmingly"),ordered = TRUE)))
    feature_names = colnames(data %>% select(starts_with("ipos")))
  }
  
  return(list("data" = data, "feature_names" = feature_names))
}









